{"version":3,"file":"devfractal-router.cjs.production.min.js","sources":["../src/MatchContext.tsx","../src/RouterContext.tsx","../src/Router.tsx","../src/SafeRoute.tsx","../src/SimpleRedirect.tsx"],"sourcesContent":["import React from 'react'\nimport { match } from 'react-router'\nimport { Mixed, TypeOf } from 'technoidentity-utils'\nimport { cast, fatal } from 'technoidentity-utils'\n\n// tslint:disable-next-line: typedef\nexport const MatchContext = React.createContext<match | undefined>(undefined)\n\nexport function useMatch<Spec extends Mixed>(\n  paramsSpec: Spec,\n): match<TypeOf<Spec>> {\n  // tslint:disable-next-line: typedef\n  const match: match | undefined = React.useContext(MatchContext)\n\n  if (match === null || match === undefined) {\n    fatal('match is null or undefined')\n  } else {\n    cast(paramsSpec, match.params)\n  }\n\n  return match as match<TypeOf<Spec>>\n}\n\nexport function useParams<Spec extends Mixed>(paramsSpec: Spec): TypeOf<Spec> {\n  const { params } = useMatch(paramsSpec)\n  return params\n}\n","import { History, Location } from 'history'\nimport { parse } from 'query-string'\nimport React from 'react'\nimport { RouteChildrenProps } from 'react-router'\nimport { Mixed, TypeOf } from 'technoidentity-utils'\nimport { cast, verify } from 'technoidentity-utils'\n// tslint:disable typedef\n\ninterface RouterContext extends RouteChildrenProps {\n  setRouteMatched(value: boolean): void\n  getRouteMatched(): boolean\n}\n\nexport const RouterContext: React.Context<RouterContext> = React.createContext<\n  RouterContext\n>((undefined as unknown) as RouterContext)\n\nexport function useRouter(): RouterContext {\n  const result = React.useContext(RouterContext)\n  verify(result !== null)\n\n  return result\n}\n\nexport function useHistory(): History {\n  const { history } = useRouter()\n\n  return history\n}\n\nexport function useLocation(): Location {\n  const { location } = useRouter()\n\n  return location\n}\n\nexport function useQuery<Spec extends Mixed>(\n  querySpec: Spec,\n): TypeOf<typeof querySpec> {\n  const location = useLocation()\n  const query = parse(location.search)\n  cast(querySpec, query)\n\n  return query\n}","import React from 'react'\nimport {\n  BrowserRouter,\n  BrowserRouterProps,\n  HashRouter,\n  HashRouterProps,\n  Route,\n} from 'react-router-dom'\nimport { RouterContext, useRouter } from './RouterContext'\n\n// tslint:disable no-class readonly-keyword no-object-mutation no-this\nclass RouteMatched {\n  private routeMatched: boolean = false\n\n  setRouteMatched = (routeMatched: boolean) => {\n    this.routeMatched = routeMatched\n  }\n\n  getRouteMatched = () => this.routeMatched\n}\n// tslint:enable no-class readonly-keyword no-object-mutation no-this\n\nexport type RouterType = 'browser' | 'hash'\n\nexport type RouterProps<T extends RouterType> = (T extends 'browser'\n  ? BrowserRouterProps\n  : HashRouterProps) & {\n  readonly variant?: T\n  readonly children: React.ReactNode\n}\n\nconst CheckRouteMatched: React.FC = () => {\n  const { getRouteMatched } = useRouter()\n  if (!getRouteMatched()) {\n    throw new Error('no route matched')\n  }\n  // tslint:disable-next-line: no-null-keyword\n  return null\n}\n\nconst RouterChildren: React.FC = ({ children }) => (\n  <Route>\n    {routeProps => (\n      <RouterContext.Provider value={{ ...routeProps, ...new RouteMatched() }}>\n        {children}\n        <CheckRouteMatched />\n      </RouterContext.Provider>\n    )}\n  </Route>\n)\n\nexport function Router<T extends RouterType>({\n  variant,\n  children,\n  ...props\n}: RouterProps<T>): JSX.Element {\n  return variant === 'browser' ? (\n    <BrowserRouter {...props}>\n      <RouterChildren>{children}</RouterChildren>\n    </BrowserRouter>\n  ) : (\n    <HashRouter {...props}>\n      <RouterChildren>{children}</RouterChildren>\n    </HashRouter>\n  )\n}\n","import React from 'react'\nimport { Route as RRRoute, RouteProps } from 'react-router-dom'\nimport { MatchContext } from './MatchContext'\nimport { useRouter } from './RouterContext'\n\nexport function Route({\n  component: Component,\n  render,\n  children,\n  exact,\n  ...props\n}: RouteProps): JSX.Element {\n  const { setRouteMatched } = useRouter()\n\n  return (\n    <RRRoute\n      {...props}\n      exact={exact !== undefined ? exact : true}\n      render={renderProps => {\n        if (setRouteMatched) {\n          setRouteMatched(true)\n        }\n\n        return (\n          <MatchContext.Provider value={renderProps.match}>\n            {Component ? (\n              <Component {...renderProps} />\n            ) : render ? (\n              render(renderProps)\n            ) : (\n              children\n            )}\n          </MatchContext.Provider>\n        )\n      }}\n    />\n  )\n}\n","import React from 'react'\nimport { Redirect, Route, RouteComponentProps } from 'react-router-dom'\nimport { useRouter } from './RouterContext'\n\nexport interface SimpleRedirectProps {\n  readonly from: string\n  readonly to: string\n  readonly exact?: boolean\n}\n\nexport const SimpleRedirect: React.FC<SimpleRedirectProps> = ({\n  from,\n  to,\n  exact,\n}) => {\n  const { setRouteMatched } = useRouter()\n  return (\n    <Route\n      exact={exact !== undefined ? exact : true}\n      path={from}\n      render={() => {\n        if (setRouteMatched) {\n          setRouteMatched(true)\n        }\n        return <Redirect to={to} />\n      }}\n    />\n  )\n}\n\nexport type RouteComponentPropsRemoved<T> = Omit<T, keyof RouteComponentProps>\n\nexport function removeRouteComponentProps<T extends RouteComponentProps>(\n  props: T,\n): RouteComponentPropsRemoved<T> {\n  const { match, location, history, staticContext, ...result } = props\n  return result\n}\n"],"names":["MatchContext","React","createContext","undefined","useMatch","paramsSpec","match","useContext","fatal","cast","params","RouterContext","useRouter","result","verify","useLocation","location","RouteMatched","routeMatched","_this","CheckRouteMatched","getRouteMatched","Error","RouterChildren","children","Route","routeProps","Provider","value","Component","component","render","exact","props","setRouteMatched","RRRoute","renderProps","variant","BrowserRouter","HashRouter","from","to","path","Redirect","history","querySpec","query","parse","search"],"mappings":"mLAMaA,EAAeC,EAAMC,mBAAiCC,YAEnDC,EACdC,OAGMC,EAA2BL,EAAMM,WAAWP,UAE9CM,MAAAA,EACFE,QAAM,8BAENC,OAAKJ,EAAYC,EAAMI,QAGlBJ,yVCPIK,EAA8CV,EAAMC,mBAE9DC,GAEH,SAAgBS,QACRC,EAASZ,EAAMM,WAAWI,UAChCG,SAAkB,OAAXD,GAEAA,EAST,SAAgBE,WACOH,IAAbI,aCpBJC,EAAN,yCACkC,uBAEd,SAACC,GACjBC,EAAKD,aAAeA,wBAGJ,kBAAMC,EAAKD,eAazBE,EAA8B,gBAE7BC,EADuBT,IAApBS,yBAEA,IAAIC,MAAM,2BAGX,MAGHC,EAA2B,gBAAGC,IAAAA,gBAClCvB,gBAACwB,aACE,SAAAC,UACCzB,gBAACU,EAAcgB,UAASC,WAAYF,KAAe,IAAIT,IACpDO,EACDvB,gBAACmB,uUCvCIS,IAAXC,UACAC,IAAAA,OACAP,IAAAA,SACAQ,IAAAA,MACGC,iDAEKC,EAAoBtB,IAApBsB,uBAGNjC,gBAACkC,yBACKF,GACJD,WAAiB7B,IAAV6B,GAAsBA,EAC7BD,OAAQ,SAAAK,UACFF,GACFA,GAAgB,GAIhBjC,gBAACD,EAAa2B,UAASC,MAAOQ,EAAY9B,OACvCuB,EACC5B,gBAAC4B,mBAAcO,IACbL,EACFA,EAAOK,GAEPZ,uCDsBZa,IAAAA,QACAb,IAAAA,SACGS,qCAGDhC,gBADiB,YAAZoC,EACJC,gBAIAC,8BAJkBN,GACjBhC,gBAACsB,OAAgBC,oDEhDsC,gBAC3DgB,IAAAA,KACAC,IAAAA,GACAT,IAAAA,MAEQE,EAAoBtB,IAApBsB,uBAENjC,gBAACwB,SACCO,WAAiB7B,IAAV6B,GAAsBA,EAC7BU,KAAMF,EACNT,OAAQ,kBACFG,GACFA,GAAgB,GAEXjC,gBAAC0C,YAASF,GAAIA,mDAS3BR,YAE+DA,sEHXjE,kBACsBrB,IAAZgC,6EDFoCvC,UACzBD,EAASC,GAApBK,kCCaRmC,OAEM7B,EAAWD,IACX+B,EAAQC,QAAM/B,EAASgC,eAC7BvC,OAAKoC,EAAWC,GAETA"}